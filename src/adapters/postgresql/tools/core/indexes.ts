/**
 * PostgreSQL Core Tools - Index Operations
 *
 * Index listing and creation tools.
 */

import type { PostgresAdapter } from "../../PostgresAdapter.js";
import type {
  ToolDefinition,
  RequestContext,
} from "../../../../types/index.js";
import { readOnly, write } from "../../../../utils/annotations.js";
import { getToolIcons } from "../../../../utils/icons.js";
import {
  GetIndexesSchema,
  CreateIndexSchemaBase,
  CreateIndexSchema,
} from "../../schemas/index.js";

/**
 * Get indexes for a table
 */
export function createGetIndexesTool(adapter: PostgresAdapter): ToolDefinition {
  return {
    name: "pg_get_indexes",
    description:
      "List indexes with usage statistics. When table is omitted, lists ALL database indexes (can be large). Use schema/limit to filter.",
    group: "core",
    inputSchema: GetIndexesSchema,
    annotations: readOnly("Get Indexes"),
    icons: getToolIcons("core", readOnly("Get Indexes")),
    handler: async (params: unknown, _context: RequestContext) => {
      const { table, schema, limit } = GetIndexesSchema.parse(params);

      // If no table specified, list all indexes in the database
      if (table === undefined || table === "") {
        const indexes = await adapter.getAllIndexes();
        // Optionally filter by schema
        const filtered =
          schema !== undefined
            ? indexes.filter((idx) => idx.schemaName === schema)
            : indexes;

        // Apply limit (default 100 for all-indexes query to avoid overwhelming results)
        const effectiveLimit = limit ?? 100;
        const limited = filtered.slice(0, effectiveLimit);
        const totalCount = filtered.length;

        return {
          indexes: limited,
          count: limited.length,
          totalCount,
          // Add hint about pagination/filtering
          ...(totalCount > effectiveLimit && {
            truncated: true,
            hint: `Showing ${String(effectiveLimit)} of ${String(totalCount)} indexes. Use 'limit' to see more, 'schema' to filter, or 'table' for specific table.`,
          }),
        };
      }

      const indexes = await adapter.getTableIndexes(table, schema);
      return {
        indexes,
        count: indexes.length,
        table: `${schema ?? "public"}.${table}`,
      };
    },
  };
}

/**
 * Create an index
 */
export function createCreateIndexTool(
  adapter: PostgresAdapter,
): ToolDefinition {
  return {
    name: "pg_create_index",
    description:
      "Create an index on a table. Supports btree, hash, gin, gist, brin index types.",
    group: "core",
    inputSchema: CreateIndexSchemaBase,
    annotations: write("Create Index"),
    icons: getToolIcons("core", write("Create Index")),
    handler: async (params: unknown, _context: RequestContext) => {
      const parsed = CreateIndexSchema.parse(params);
      const {
        name,
        table,
        schema,
        columns,
        unique,
        type,
        where,
        concurrently,
        ifNotExists,
      } = parsed;

      const schemaName = schema ?? "public";

      // Track if name was auto-generated
      const rawParams = params as Record<string, unknown> | null;
      const wasAutoGenerated =
        rawParams !== null &&
        rawParams["name"] === undefined &&
        rawParams["indexName"] === undefined;

      // If ifNotExists is true, check if index already exists BEFORE creating
      if (ifNotExists === true) {
        const checkSql = `
                    SELECT 1 FROM pg_indexes 
                    WHERE schemaname = $1 AND indexname = $2
                `;
        const checkResult = await adapter.executeQuery(checkSql, [
          schemaName,
          name,
        ]);
        if (checkResult.rows && checkResult.rows.length > 0) {
          return {
            success: true,
            index: name,
            indexName: name, // Alias for clarity
            table: `${schemaName}.${table}`,
            ifNotExists: true,
            alreadyExists: true,
            message: `Index ${name} already exists`,
            ...(wasAutoGenerated && { generatedName: true }),
          };
        }
      }

      const schemaPrefix = schema ? `"${schema}".` : "";
      const uniqueClause = unique ? "UNIQUE " : "";
      const concurrentlyClause = concurrently ? "CONCURRENTLY " : "";
      const usingClause = type ? `USING ${type} ` : "";
      const whereClause = where ? ` WHERE ${where}` : "";

      // Support expression indexes: detect expressions (containing parentheses or operators)
      // and don't quote them
      const isExpression = (col: string): boolean => {
        return col.includes("(") || col.includes(" ") || col.includes("::");
      };
      const columnList = columns
        .map((c) => (isExpression(c) ? c : `"${c}"`))
        .join(", ");

      const sql =
        `CREATE ${uniqueClause}INDEX ${concurrentlyClause}"${name}" ` +
        `ON ${schemaPrefix}"${table}" ${usingClause}(${columnList})${whereClause}`;

      try {
        await adapter.executeQuery(sql);
        return {
          success: true,
          index: name,
          indexName: name, // Alias for clarity
          table: `${schemaName}.${table}`,
          sql,
          ...(wasAutoGenerated && { generatedName: true }),
        };
      } catch (error: unknown) {
        // If ifNotExists is true and the error is "already exists", return success with alreadyExists flag
        // (This handles race conditions where index is created between check and create)
        if (ifNotExists === true && error instanceof Error) {
          const msg = error.message.toLowerCase();
          if (msg.includes("already exists") || msg.includes("duplicate")) {
            return {
              success: true,
              index: name,
              indexName: name,
              table: `${schemaName}.${table}`,
              ifNotExists: true,
              alreadyExists: true,
              message: `Index ${name} already exists`,
              ...(wasAutoGenerated && { generatedName: true }),
            };
          }
        }
        // Re-throw other errors
        throw error;
      }
    },
  };
}

import { z } from "zod";

/**
 * Preprocess table parameters for drop index
 */
function preprocessDropIndexParams(input: unknown): unknown {
  if (typeof input !== "object" || input === null) return input;
  const result = { ...(input as Record<string, unknown>) };

  // Alias: index/indexName â†’ name
  if (result["name"] === undefined) {
    if (result["index"] !== undefined) result["name"] = result["index"];
    else if (result["indexName"] !== undefined)
      result["name"] = result["indexName"];
  }

  // Parse schema.name format
  if (
    typeof result["name"] === "string" &&
    result["name"].includes(".") &&
    result["schema"] === undefined
  ) {
    const parts = result["name"].split(".");
    if (parts.length === 2) {
      result["schema"] = parts[0];
      result["name"] = parts[1];
    }
  }

  return result;
}

// Base schema for MCP visibility - exported for inputSchema
export const DropIndexSchemaBase = z.object({
  name: z
    .string()
    .optional()
    .describe("Index name (supports schema.name format)"),
  index: z.string().optional().describe("Alias for name"),
  indexName: z.string().optional().describe("Alias for name"),
  schema: z.string().optional().describe("Schema name (default: public)"),
  ifExists: z
    .boolean()
    .optional()
    .describe("Use IF EXISTS to avoid errors if index does not exist"),
  cascade: z
    .boolean()
    .optional()
    .describe("Use CASCADE to drop dependent objects"),
  concurrently: z
    .boolean()
    .optional()
    .describe("Drop concurrently (does not lock table)"),
});

// Transformed schema for handler validation
const DropIndexSchema = z
  .preprocess(preprocessDropIndexParams, DropIndexSchemaBase)
  .transform((data) => ({
    ...data,
    name: data.name ?? data.index ?? data.indexName ?? "",
  }))
  .refine((data) => data.name !== "", {
    message: "name (or index/indexName alias) is required",
  });

/**
 * Drop an index
 */
export function createDropIndexTool(adapter: PostgresAdapter): ToolDefinition {
  return {
    name: "pg_drop_index",
    description:
      "Drop an index from a table. Supports IF EXISTS, CASCADE, and CONCURRENTLY options.",
    group: "core",
    inputSchema: DropIndexSchemaBase,
    annotations: write("Drop Index"),
    icons: getToolIcons("core", write("Drop Index")),
    handler: async (params: unknown, _context: RequestContext) => {
      const { name, schema, ifExists, cascade, concurrently } =
        DropIndexSchema.parse(params);

      const schemaName = schema ?? "public";
      const ifExistsClause = ifExists === true ? "IF EXISTS " : "";
      const cascadeClause = cascade === true ? " CASCADE" : "";
      const concurrentlyClause = concurrently === true ? "CONCURRENTLY " : "";

      const sql = `DROP INDEX ${concurrentlyClause}${ifExistsClause}"${schemaName}"."${name}"${cascadeClause}`;

      await adapter.executeQuery(sql);
      return {
        success: true,
        index: `${schemaName}.${name}`,
        sql,
      };
    },
  };
}
